<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>superisaac</title>    
    <link rel="stylesheet" href="../main.css"/>
  </head>
  <body>
    <div class="wrap">    
      <nav>
        <a href="/">Home</a>
      </nav>
      <div class="article">
        <h1>A global object view for websites</h1><h2>Brief</h2><p>The continuous increment of website functions leads to multiple
projects, the data access of projects is made in arbitrary way and
tend to be hard to maintain.</p>
<p>This article raises a proposal to clear multi-projects architecture
and provide global view of the whole website so that cross-project
calling is easier, we call it ObjPuller within the current context.</p>
<p>ObjPuller is a proxy server written in <a href="https://golang.org">golang</a>,
it connects memcached instances for storage, all objects is in it is
volatile, this policy makes the server easy to maintain and
scale. Restarting memcached vacuumizes memory; Adding new memcached
increases capacity. Most data services are from cache instead of from
remote backends, so that the fetching speed can keep high.</p>
<p>ObjPuller has backends, each backend is a plain old project that
exposing services to ObjPuller server. ObjPuller&#39;s typical data access
functions are listed as the following.</p>
<ol>
<li>client request the data of key &quot;auth/user/1003&quot;, the key format is
&quot;:backend/:model/:pk&quot;.</li>
<li>ObjPuller server try to lookup that key in the cache, if the cache
hits, just respond the value to client and end query.</li>
<li>else if the cache misses, ObjPuller server get the target address
of backend named &quot;auth&quot;, send an object request to that backend,
pull the result object and insert it into the cache, respond the
client and then end the request. Thus cache will hit at the next
time.</li>
<li>when the object in a backend changes, the backend take in charge of
purging the cache by requesting ObjPuller server&#39;s API.</li>
<li>backends also provide query/mutation URLs as ObjPuller&#39;s proxy
target, the response from them are checked to update cache.</li>
</ol>
<h2>Configure</h2><p>Sample yaml configuration is like</p>
<pre><code class="language-yaml">version: 1
ssl:
  cert: some.cert
  key: some.key

auth:
  bear-token: aaadsdd

memcached:
  - address: 127.0.0.1:11211
  - address: 192.168.1.23:11211

pubsub:
  url: redis://192.168.1.113:6379

backends:
  auth:
    models:
      - user

    token: &quot;aasdffd&quot;
    target: &quot;https://auth.example.com/datamodel/&quot;

  relation:
    models:
      - friends
      - followers

    token: &quot;aasdffd&quot;
    target: &quot;https://relation.example.com/datamodel/&quot;

    queries:
      - userfriends
      - userfollowers
    mutations:
      - followuser
      - unfollowuer

  exchange:
    models:
      - product
      - order

    token: &quot;ffff&quot;
    target: &quot;https://exchange.example.com/datamodel/&quot;
</code></pre>
<h2>Concept</h2><p>ObjPuller handles JSON objects, a basic entry is as simple as a JSON
objects with two fields</p>
<ul>
<li><code>oid</code>, oid is the identifier of an object, it follow the format
&quot;:backend/:model/:pk&quot;.</li>
<li><code>data</code> [optional], the related data model, the field can be arbitary
valid JSON documents.</li>
</ul>
<pre><code class="language-javascript">{
  &quot;oid&quot;: &quot;auth/user/1003&quot;,
  // data field is optional
  &quot;data&quot;: {
      &quot;name&quot;: &quot;tom&quot;,
      &quot;age&quot;: 28
      &quot;gender&quot;: &quot;female&quot;
  },
  &quot;expire&quot;: 10 // expire is optional, default is 0, which means never expire
}
</code></pre>
<h2>Interfaces</h2><p>ObjPuller can provide some more interfaces, including RESTful, JSONRPC,
memcached protocol, thrift and gRPC, it can even be the basis of
graphql server, here I only list a RESTful interface to make things
simpler</p>
<h3>Get object by oid</h3><pre><code>GET /v1/objects/:backend/:model/:pk

if cache misses, the request is proxied to 
GET :backend.target/:backend/:model/:pk
</code></pre><p>Simply lookup the oid in cache or else resoult to backends.</p>
<h3>Multi Get by oid list</h3><pre><code>GET /v1/objects/?objects=auth/user/1,relation/friends/1,relation/followers/1&amp;delim=,
C&lt;-S
[
  {
    &quot;oid&quot;: &quot;auth/user/1&quot;,
    &quot;data&quot;: {
        &quot;name&quot;: &quot;hello&quot;,
        &quot;id&quot;: 1,
        &quot;gender&quot;: &quot;female&quot;
     }
  },
  ...
]
if some caches miss, the request is proxied to 
GET :backend.target/:backend/?objects=.....
</code></pre><p>Perform multiple GETs in a single round trip, the <code>objects</code> is separated by
chars from <code>delim</code> field or COMMA.</p>
<h3>Update objects by oid</h3><pre><code>POST /v1/objects/
C-&gt;S
[
  {
    &quot;oid&quot;: &quot;auth/user/1&quot;,
    &quot;data&quot;: {
        &quot;name&quot;: &quot;hello&quot;,
        &quot;id&quot;: 1,
        &quot;gender&quot;: &quot;female&quot;
     },
     expire: 60 // expire is optional
  },
  ...
]
</code></pre><p>Should be called by backends to purge/update caches, when <code>data</code> field
request body is not given the action would be to purge cache by oid</p>
<h3>Delete object by oid</h3><pre><code>DELETE /v1/objects/:backend/:model/:pk
</code></pre><p>Delete an object by key</p>
<h3>Proxy query</h3><pre><code>GET /v1/query/:backend/:query?p1=a&amp;u=7

Backend server should provide an url 
GET :backend.target/:backend/:query
</code></pre><p>Proxy a query action to backend, the valid response(following the
entry format) will be saved to cache. Backend can also respond entries
containing only <code>oid</code> field, ObjPuller can automatically lookup there
data when needed.</p>
<h3>Proxy mutation</h3><pre><code>POST /v1/mutation/:backend/:mutation
C-&gt;S
{
  // any JSON or form data
}

Backend server should provide an url 
POST :backend.target/:backend/:mutation
</code></pre><p>Proxy a query action to backend, the valid response(following the
entry format) will be saved to cache. Backend can also respond entries
containing only <code>oid</code> field, ObjPuller can automatically lookup their
data when needed.</p>
<h2>Pubsub changes</h2><p>Sometimes backends with to get notified when other relavent cache
changed, they can subscribe to a websocket connection
ws://<server>/objects/change/:backend, the received messages are a
stream of entries.</server></p>
<pre><code class="language-json">{
  &quot;oid&quot;: &quot;relation/userfriends/1009&quot;,
  &quot;data&quot;: ...
}
</code></pre>
        <div class="push"></div>
      </div>
    </div>
    <footer>
      @2017-2018 superisaac.github.io
    </footer>
  </body>
</html>
