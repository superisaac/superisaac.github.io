<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>superisaac</title>    
    <link rel="stylesheet" href="../main.css"/>
  </head>
  <body>
    <div class="wrap">    
      <nav>
        <a href="/">Home</a>
      </nav>
      <div class="article">
        <h1>A global object view for websites</h1><h2>Brief</h2><p>The continuous increment of website functions leads to multiple
projects, the data access of projects is made in arbitrary way and
tend to be hard to maintain.</p>
<p>This article raises a proposal to clear multi-projects architecture
and provide global view JSON data of the whole website so than
cross-project calling is easier, we call it bObject from the current
context.</p>
<p>bObject is a proxy server written in <a href="https://golang.org">golang</a>, it
connects memcached instances for storage, all objects is stored in
volatile memory, this policy makes the server easy to maintain and
scale. Restarting memcached vacuumizes memory; Adding new memcached
increases capacity.</p>
<p>bObject has backends, each backend is an old project that provides
services to bObject server. bObject data access is listed as</p>
<ol>
<li>client request the data of key &quot;auth/user/1003&quot;, the key format is
&quot;:backend/:model/:pk&quot;.</li>
<li>bObject server try to lookup the cache for that key, if the cache
hits, just respond the client and terminate.</li>
<li>else if the cache misses, bObject server get the target address of
backend &quot;auth&quot;, proxy an object request to that backend, put the
success result into cache, respond the client and then end the
request. Thus cache will hit at the next time.</li>
<li>when the object in a backend changes, the backend take in charge of
purging the cache by requesting bObject server&#39;s interface.</li>
<li>backends also provide query/mutation URLs as bObject&#39;s proxy
target, the response from them are checked to update cache.</li>
</ol>
<h2>Configure</h2><p>Sample configuration is like</p>
<pre><code class="language-yaml">version: 1
memcached:
  - address: 127.0.0.1:11211
  - address: 192.168.1.23:11211

backends:
  auth:
    token: &quot;aasdffd&quot;
    target: &quot;https://auth.example.com/datamodel/&quot;

  relation:
    token: &quot;aasdffd&quot;
    target: &quot;https://relation.example.com/datamodel/&quot;

    queries:
      - friends
      - followers
    mutations:
      - follow

  exchange:
    token: &quot;ffff&quot;
    target: &quot;https://exchange.example.com/datamodel/&quot;
</code></pre>
<h2>Concept</h2><p>bObject handles JSON objects, a basic entry is as simple as a JSON
objects with two fields</p>
<ul>
<li><code>oid</code>, oid is the identifier of an object, it follow the format
&quot;:backend/:model/:pk&quot;.</li>
<li><code>data</code> [optional], the related data model, the field can be arbitary
valid JSON documents.</li>
</ul>
<pre><code class="language-javascript">{
  &quot;oid&quot;: &quot;auth/user/1003&quot;,
  // data field is optional
  &quot;data&quot;: {
      &quot;name&quot;: &quot;tom&quot;,
      &quot;age&quot;: 28
      &quot;gender&quot;: &quot;female&quot;
  }
}
</code></pre>
<h2>Interfaces</h2><p>bObject can provide some more interfaces, including RESTful, JSONRPC,
memcached protocol, thrift and gRPC, here I only list a RESTful
interface to make things simpler</p>
<h3>Get object by oid</h3><pre><code>GET /v1/objects/:backend/:model/:pk

if cache misses, the request is proxied to 
GET :backend.target/:backend/:model/:pk
</code></pre><p>Simply lookup the oid in cache or else resoult to backends.</p>
<h3>Multi Get by oid list</h3><pre><code>GET /v1/objects/?objects=auth/user/1,relation/friends/1,relation/followers/1&amp;delim=,
C&lt;-S
[
  {
    &quot;oid&quot;: &quot;auth/user/1&quot;,
    &quot;data&quot;: {
        &quot;name&quot;: &quot;hello&quot;,
        &quot;id&quot;: 1,
        &quot;gender&quot;: &quot;female&quot;
     }
  },
  ...
]
if some caches miss, the request is proxied to 
GET :backend.target/:backend/?objects=.....
</code></pre><p>Perform multiple GETs in a single round trip, the <code>objects</code> is separated by
chars from <code>delim</code> field or COMMA.</p>
<h3>Update objects by oid</h3><pre><code>POST /v1/objects/
C-&gt;S
[
  {
    &quot;oid&quot;: &quot;auth/user/1&quot;,
    &quot;data&quot;: {
        &quot;name&quot;: &quot;hello&quot;,
        &quot;id&quot;: 1,
        &quot;gender&quot;: &quot;female&quot;
     }
  },
  ...
]
</code></pre><p>Should be called by backends to purge/update caches, when <code>data</code> field
request body misses the action would be to purge cache by oid</p>
<h3>Delete object by oid</h3><pre><code>DELETE /v1/objects/:backend/:model/:pk
</code></pre><p>Delete an object by key</p>
<h3>Proxy query</h3><pre><code>GET /v1/query/:backend/:query?p1=a&amp;u=7

Backend server should provide an url 
GET :backend.target/:backend/:query
</code></pre><p>Proxy a query action to backend, the valid response(following the
entry format) will be saved to cache. Backend can also respond entries
containing only <code>oid</code> field, bObject can automatically lookup there
data when needed.</p>
<h3>Proxy mutation</h3><pre><code>POST /v1/query/:backend/:query
C-&gt;S
{
  // any JSON or form data
}

Backend server should provide an url 
POST :backend.target/:backend/:query
</code></pre><p>Proxy a query action to backend, the valid response(following the
entry format) will be saved to cache. Backend can also respond entries
containing only <code>oid</code> field, bObject can automatically lookup there
data when needed.</p>
        <div class="push"></div>
      </div>
    </div>
    <footer>
      @2017-2018 superisaac.github.io
    </footer>
  </body>
</html>
